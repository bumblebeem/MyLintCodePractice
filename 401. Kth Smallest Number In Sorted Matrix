class Number{
    public int x, y, value;
    Number(int x, int y, int v){
        this.x = x;
        this.y = y;
        this.value = v;
    }
}

class NumComparator implements Comparator<Number> {
    public int compare(Number a, Number b) {
        return a.value - b.value;
    }
}

public class Solution {
    /**
     * @param matrix: a matrix of integers
     * @param k: an integer
     * @return: the kth smallest number in the matrix
     */
    int[] dx = {0, 1};
    int[] dy = {1, 0};
     
    public int kthSmallest(int[][] matrix, int k) {
        if(matrix == null || matrix.length == 0){
            return -1;
        }
        if(matrix.length * matrix[0].length < k){
            return -1;
        }
        
        PriorityQueue<Number> heap = new PriorityQueue<Number>(k, new NumComparator());
        boolean[][] traversed = new boolean[matrix.length][matrix[0].length];
        heap.add(new Number(0, 0, matrix[0][0]));
        traversed[0][0] = true;
        
        for(int i = 0; i < k - 1; i ++){
            Number cur = heap.poll();
            for(int j = 0; j < 2; j ++){
                int nx = cur.x + dx[j];
                int ny = cur.y + dy[j];
                if(isValid(nx, ny, matrix, traversed)){
                    traversed[nx][ny] = true;
                    heap.add(new Number(nx, ny, matrix[nx][ny]));
                }
            }
        }
        
        return heap.peek().value;
    }
    
    private boolean isValid(int x, int y, int[][] matrix, boolean[][] traversed){
        if(x < matrix.length && y < matrix[x].length && !traversed[x][y]){
            return true;
        }
        return false;
    }
}
